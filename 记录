好的，二叉树是算法面试中的绝对主角，题目种类繁多但模式相对固定。掌握了核心思想后，很多问题都能迎刃而解。

下面我将二叉树的经典题目分为几个大类，由浅入深，并附上对应的 LeetCode 题号，方便你进行专项练习。

---

### 类别一：二叉树的基础 — 遍历

遍历是所有二叉树问题的基础，必须滚瓜烂熟。所有其他问题几乎都是在遍历的基础上进行修改和扩展。

**核心思想**：按照特定顺序访问树中的每一个节点。

1.  **深度优先搜索 (DFS)**
    * **前序遍历 (Pre-order)**: 根 -> 左 -> 右 (LeetCode 144)
    * **中序遍历 (In-order)**: 左 -> 根 -> 右 (LeetCode 94)
    * **后序遍历 (Post-order)**: 左 -> 右 -> 根 (LeetCode 145)
    * **关键**：以上三种遍历都必须掌握**递归**和**迭代（使用栈）**两种写法。面试官在考察完递归后，很可能会追问迭代的实现。

2.  **广度优先搜索 (BFS)**
    * **层序遍历 (Level-order)**: 从上到下，从左到右，一层一层地遍历。(LeetCode 102)
    * **关键**：层序遍历通常使用**队列 (Queue)** 来实现。这个问题有很多变种，比如：
        * **N 叉树的层序遍历** (LeetCode 429)
        * **自底向上的层序遍历** (LeetCode 107)
        * **鋸齒形（Z字形）层序遍历** (LeetCode 103)

---

### 类别二：二叉树的属性与计算

这类问题通常是在遍历的基础上，通过递归函数的返回值来获取信息，计算树的各种属性。

1.  **树的深度/高度**
    * **最大深度**: 根节点到最远叶子节点的最长路径上的节点数。(LeetCode 104)
        * **思路**: `max(左子树深度, 右子树深度) + 1`
    * **最小深度**: 根节点到最近叶子节点的最短路径上的节点数。(LeetCode 111)
        * **注意**: 需要处理节点只有一个子树的情况。BFS 解法更直观。

2.  **树的平衡与对称**
    * **平衡二叉树**: 判断一个二叉树是否是高度平衡的（任何节点的左右子树高度差不超过1）。(LeetCode 110)
        * **思路**: 后序遍历的应用。在计算深度的同时，判断是否平衡。
    * **对称二叉树**: 判断一棵树是否是自身的镜像。(LeetCode 101)
        * **思路**: 需要一个辅助递归函数，比较两棵树（根节点的左子树和右子树）是否对称。

3.  **树的直径**
    * **二叉树的直径**: 树中任意两个节点之间最长路径的长度。(LeetCode 543)
        * **思路**: 对于每个节点，经过它的最长路径是其`左子树深度 + 右子树深度`。最终结果是所有节点这个值的最大值。

---

### 类别三：路径问题

这类问题通常需要用深度优先搜索来寻找满足特定条件的路径。

1.  **路径总和 (Path Sum)**
    * **路径总和 I**: 判断是否存在一条从根到叶子的路径，使得路径上节点值之和等于 `target`。(LeetCode 112)
    * **路径总和 II**: 找出所有这样的路径。(LeetCode 113)
        * **思路**: 这是典型的**回溯算法**在树上的应用。
    * **最大路径和**: 找出任意两个节点之间路径和的最大值（路径可以不经过根节点）。(LeetCode 124 - **高难度**)

---

### 类别四：二叉树的构造

这类问题考验你对遍历顺序的深刻理解。

1.  **从前序与中序遍历序列构造二叉树** (LeetCode 105)
2.  **从中序与后序遍历序列构造二叉树** (LeetCode 106)
    * **核心思路**:
        * 前序/后序遍历的第一个/最后一个元素是当前子树的**根节点**。
        * 在中序遍历中找到这个根节点，它的左边就是**左子树**的所有节点，右边就是**右子树**的所有节点。
        * 根据左右子树的节点数量，可以确定在前序/后序遍历中左右子树的范围，然后递归构造。

---

### 类别五：特殊树与进阶问题

1.  **最近公共祖先 (LCA)**
    * **二叉树的最近公共祖先**: (LeetCode 236)
        * **思路**: 非常经典的递归问题。从根节点开始，如果当前节点是 p 或 q，或者 p 和 q 分别在当前节点的左右子树，那么当前节点就是LCA。
    * **二叉搜索树的最近公共祖先**: (LeetCode 235)
        * **思路**: 利用二叉搜索树的性质，比普通二叉树简单得多。

2.  **二叉搜索树 (BST)**
    BST 是非常重要的一种特殊二叉树，性质是：`左子树所有节点 < 根节点 < 右子树所有节点`。
    * **验证二叉搜索树**: (LeetCode 98)
        * **关键**: 不仅要和左右子节点比较，还要保证整个左子树/右子树都满足条件。通常用中序遍历（结果应为升序）或在递归中传递上下界来解决。
    * **将有序数组转换为二叉搜索树**: (LeetCode 108)
    * **二叉搜索树中第K小的元素**: (LeetCode 230)

3.  **翻转与修改**
    * **翻转二叉树**: (LeetCode 226)
    * **将二叉树展开为链表**: (LeetCode 114)

4.  **序列化与反序列化**
    * **二叉树的序列化与反序列化**: 将树结构转换为字符串，并能从字符串恢复。(LeetCode 297 - **高难度**)

### 学习建议

1.  **从遍历开始**：确保你能不假思索地写出所有遍历的递归和迭代版本。
2.  **画图**：对于任何二叉树问题，在纸上画出递归过程和树的形态，是理清思路的最佳方式。
3.  **掌握递归思想**：深刻理解递归函数的**定义**（它能解决什么问题）和**返回值**（它能向上一层提供什么信息）。
4.  **分类练习**：按照上面的分类进行专项练习，有助于你识别问题的模式。